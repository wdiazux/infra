# Zitadel OIDC Sync CronJob
#
# Automatically creates and maintains OIDC applications and Kubernetes secrets.
# Runs periodically to ensure SSO configuration is always correct.
#
# Features:
# - Self-healing: recreates apps/secrets if deleted or after Zitadel DB reset
# - Idempotent: safe to run multiple times, only updates when needed
# - Automated pod restarts: only restarts pods when secrets change
#
# Applications managed:
# - grafana (monitoring) - PKCE
# - forgejo (forgejo) - PKCE
# - immich (media) - Client Secret
# - open-webui (ai) - Client Secret
# - paperless (management) - Client Secret
# - oauth2-proxy (auth) - Client Secret
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: zitadel-oidc-setup-script
  namespace: auth
data:
  setup.sh: |
    #!/bin/bash
    set -e

    ZITADEL_URL="http://zitadel.auth.svc.cluster.local:8080"
    MAX_RETRIES=30
    RETRY_INTERVAL=10
    SECRETS_CHANGED=false

    echo "=== Zitadel OIDC Sync $(date -Iseconds) ==="

    # Read PAT from K8s Secret (created by chart's machinekeyWriter sidecar)
    ACCESS_TOKEN=$(kubectl get secret iam-admin-pat -n auth -o jsonpath='{.data.pat}' 2>/dev/null | base64 -d 2>/dev/null)
    if [ -z "$ACCESS_TOKEN" ]; then
      echo "PAT secret not found. Zitadel may not be initialized yet."
      echo "Will retry on next scheduled run."
      exit 0
    fi
    echo "PAT secret found."

    # Zitadel uses domain-based instance resolution, so all API requests
    # must include the correct Host header matching ExternalDomain.
    ZITADEL_HOST="auth.home-infra.net"

    # Check if Zitadel is ready
    if ! curl -sf -H "Host: $ZITADEL_HOST" "$ZITADEL_URL/debug/healthz" > /dev/null 2>&1; then
      echo "Zitadel not ready. Will retry on next scheduled run."
      exit 0
    fi
    echo "Zitadel is ready."

    # Helper function to make authenticated API calls
    zitadel_api() {
      local method=$1
      local endpoint=$2
      local data=$3

      curl -sf -X "$method" "$ZITADEL_URL$endpoint" \
        -H "Host: $ZITADEL_HOST" \
        -H "Authorization: Bearer $ACCESS_TOKEN" \
        -H "Content-Type: application/json" \
        ${data:+-d "$data"}
    }

    # Get organization ID
    ORG_RESPONSE=$(zitadel_api GET "/management/v1/orgs/me")
    ORG_ID=$(echo "$ORG_RESPONSE" | jq -r '.org.id')
    echo "Organization ID: $ORG_ID"

    # Create or get HOMELAB project
    PROJECT_RESPONSE=$(zitadel_api POST "/management/v1/projects" '{"name":"HOMELAB"}' 2>/dev/null || true)

    if [ -z "$PROJECT_RESPONSE" ]; then
      # Project might already exist, search for it
      PROJECTS=$(zitadel_api POST "/management/v1/projects/_search" '{"query":{"offset":"0","limit":100}}')
      PROJECT_ID=$(echo "$PROJECTS" | jq -r '.result[] | select(.name=="HOMELAB") | .id')
    else
      PROJECT_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.id')
    fi

    if [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ]; then
      echo "ERROR: Failed to create or find HOMELAB project"
      exit 1
    fi
    echo "Project ID: $PROJECT_ID"

    # Function to get existing app by name
    get_app_by_name() {
      local name=$1
      local apps=$(zitadel_api POST "/management/v1/projects/$PROJECT_ID/apps/_search" '{"queries":[]}')
      echo "$apps" | jq -r "(.result // [])[] | select(.name==\"$name\")"
    }

    # Function to create or get OIDC application
    # Returns JSON on stdout; log messages go to stderr
    ensure_oidc_app() {
      local name=$1
      local redirect_uri=$2
      local post_logout_uri=$3
      local auth_method=$4

      # Check if app already exists
      local existing_app=$(get_app_by_name "$name")
      if [ -n "$existing_app" ] && [ "$existing_app" != "null" ]; then
        local app_id=$(echo "$existing_app" | jq -r '.id')
        echo "  App '$name' exists (ID: $app_id)" >&2
        # Get full app details (GET wraps response in .app, unwrap it)
        zitadel_api GET "/management/v1/projects/$PROJECT_ID/apps/$app_id" | jq '.app // .'
        return
      fi

      echo "  Creating app '$name'..." >&2
      local app_data=$(cat <<EOF
    {
      "name": "$name",
      "redirectUris": ["$redirect_uri"],
      "postLogoutRedirectUris": ["$post_logout_uri"],
      "responseTypes": ["OIDC_RESPONSE_TYPE_CODE"],
      "grantTypes": ["OIDC_GRANT_TYPE_AUTHORIZATION_CODE", "OIDC_GRANT_TYPE_REFRESH_TOKEN"],
      "appType": "OIDC_APP_TYPE_WEB",
      "authMethodType": "$auth_method",
      "accessTokenType": "OIDC_TOKEN_TYPE_BEARER",
      "version": "OIDC_VERSION_1_0"
    }
    EOF
    )

      local response=$(zitadel_api POST "/management/v1/projects/$PROJECT_ID/apps/oidc" "$app_data")
      if [ -z "$response" ]; then
        echo "  ERROR: Failed to create app '$name'" >&2
        return 1
      fi
      echo "  Created app '$name'" >&2
      echo "$response"
    }

    # Function to ensure Kubernetes secret exists with correct values
    ensure_k8s_secret() {
      local name=$1
      local namespace=$2
      local client_id=$3
      local client_secret=$4

      # Check if namespace exists
      if ! kubectl get namespace "$namespace" > /dev/null 2>&1; then
        echo "  Namespace '$namespace' doesn't exist, skipping secret '$name'"
        return
      fi

      # Get existing secret
      local existing_secret=$(kubectl get secret "$name" -n "$namespace" -o json 2>/dev/null || echo "")

      if [ -n "$existing_secret" ]; then
        # Compare values
        local existing_client_id=$(echo "$existing_secret" | jq -r '.data["client-id"]' | base64 -d 2>/dev/null || echo "")

        if [ "$existing_client_id" = "$client_id" ]; then
          echo "  Secret '$name' in '$namespace' is up-to-date"
          return
        fi
        echo "  Secret '$name' in '$namespace' needs update"
      else
        echo "  Creating secret '$name' in '$namespace'"
      fi

      # Delete and recreate secret
      kubectl delete secret "$name" -n "$namespace" 2>/dev/null || true

      if [ -n "$client_secret" ] && [ "$client_secret" != "null" ]; then
        kubectl create secret generic "$name" -n "$namespace" \
          --from-literal=client-id="$client_id" \
          --from-literal=client-secret="$client_secret"
      else
        kubectl create secret generic "$name" -n "$namespace" \
          --from-literal=client-id="$client_id"
      fi

      # Add labels
      kubectl label secret "$name" -n "$namespace" \
        app.kubernetes.io/managed-by=zitadel-oidc-setup \
        app.kubernetes.io/part-of=zitadel-sso

      SECRETS_CHANGED=true
    }

    # Process OIDC applications
    echo ""
    echo "=== Syncing OIDC Applications ==="

    # Grafana (with secret - Grafana's oauth2 library always sends client_secret)
    echo "Processing: grafana"
    GRAFANA_RESPONSE=$(ensure_oidc_app "grafana" \
      "https://grafana.home-infra.net/login/generic_oauth" \
      "https://grafana.home-infra.net" \
      "OIDC_APP_AUTH_METHOD_TYPE_BASIC")
    GRAFANA_CLIENT_ID=$(echo "$GRAFANA_RESPONSE" | jq -r '.clientId // .oidcConfig.clientId')
    GRAFANA_CLIENT_SECRET=$(echo "$GRAFANA_RESPONSE" | jq -r '.clientSecret // .oidcConfig.clientSecret')
    ensure_k8s_secret "grafana-oidc-secrets" "monitoring" "$GRAFANA_CLIENT_ID" "$GRAFANA_CLIENT_SECRET"

    # Forgejo (PKCE - no secret)
    echo "Processing: forgejo"
    FORGEJO_RESPONSE=$(ensure_oidc_app "forgejo" \
      "https://git.home-infra.net/user/oauth2/zitadel/callback" \
      "https://git.home-infra.net" \
      "OIDC_APP_AUTH_METHOD_TYPE_NONE")
    FORGEJO_CLIENT_ID=$(echo "$FORGEJO_RESPONSE" | jq -r '.clientId // .oidcConfig.clientId')
    ensure_k8s_secret "forgejo-oidc-secrets" "forgejo" "$FORGEJO_CLIENT_ID" ""

    # Immich (with secret)
    echo "Processing: immich"
    IMMICH_RESPONSE=$(ensure_oidc_app "immich" \
      "https://photos.reynoza.org/auth/login" \
      "https://photos.reynoza.org" \
      "OIDC_APP_AUTH_METHOD_TYPE_BASIC")
    IMMICH_CLIENT_ID=$(echo "$IMMICH_RESPONSE" | jq -r '.clientId // .oidcConfig.clientId')
    IMMICH_CLIENT_SECRET=$(echo "$IMMICH_RESPONSE" | jq -r '.clientSecret // .oidcConfig.clientSecret')
    ensure_k8s_secret "immich-oidc-secrets" "media" "$IMMICH_CLIENT_ID" "$IMMICH_CLIENT_SECRET"

    # Open WebUI (with secret)
    echo "Processing: open-webui"
    OPENWEBUI_RESPONSE=$(ensure_oidc_app "open-webui" \
      "https://chat.home-infra.net/oauth/oidc/callback" \
      "https://chat.home-infra.net" \
      "OIDC_APP_AUTH_METHOD_TYPE_BASIC")
    OPENWEBUI_CLIENT_ID=$(echo "$OPENWEBUI_RESPONSE" | jq -r '.clientId // .oidcConfig.clientId')
    OPENWEBUI_CLIENT_SECRET=$(echo "$OPENWEBUI_RESPONSE" | jq -r '.clientSecret // .oidcConfig.clientSecret')
    ensure_k8s_secret "open-webui-oidc-secrets" "ai" "$OPENWEBUI_CLIENT_ID" "$OPENWEBUI_CLIENT_SECRET"

    # Paperless (with secret)
    echo "Processing: paperless"
    PAPERLESS_RESPONSE=$(ensure_oidc_app "paperless" \
      "https://paperless.home-infra.net/accounts/oidc/zitadel/login/callback/" \
      "https://paperless.home-infra.net" \
      "OIDC_APP_AUTH_METHOD_TYPE_BASIC")
    PAPERLESS_CLIENT_ID=$(echo "$PAPERLESS_RESPONSE" | jq -r '.clientId // .oidcConfig.clientId')
    PAPERLESS_CLIENT_SECRET=$(echo "$PAPERLESS_RESPONSE" | jq -r '.clientSecret // .oidcConfig.clientSecret')
    ensure_k8s_secret "paperless-oidc-secrets" "management" "$PAPERLESS_CLIENT_ID" "$PAPERLESS_CLIENT_SECRET"

    # oauth2-proxy (with secret, for forward auth)
    echo "Processing: oauth2-proxy"
    OAUTH2PROXY_RESPONSE=$(ensure_oidc_app "oauth2-proxy" \
      "https://auth.home-infra.net/oauth2/callback" \
      "https://auth.home-infra.net" \
      "OIDC_APP_AUTH_METHOD_TYPE_BASIC")
    OAUTH2PROXY_CLIENT_ID=$(echo "$OAUTH2PROXY_RESPONSE" | jq -r '.clientId // .oidcConfig.clientId')
    OAUTH2PROXY_CLIENT_SECRET=$(echo "$OAUTH2PROXY_RESPONSE" | jq -r '.clientSecret // .oidcConfig.clientSecret')
    ensure_k8s_secret "oauth2-proxy-oidc-secrets" "auth" "$OAUTH2PROXY_CLIENT_ID" "$OAUTH2PROXY_CLIENT_SECRET"

    # Only restart pods if secrets changed
    if [ "$SECRETS_CHANGED" = "true" ]; then
      echo ""
      echo "=== Restarting Pods (secrets changed) ==="
      kubectl rollout restart deployment grafana -n monitoring 2>/dev/null || echo "  Grafana not found"
      kubectl rollout restart deployment immich-server -n media 2>/dev/null || echo "  Immich not found"
      kubectl rollout restart deployment open-webui -n ai 2>/dev/null || echo "  Open WebUI not found"
      kubectl rollout restart deployment paperless-server -n management 2>/dev/null || echo "  Paperless not found"
      kubectl rollout restart deployment oauth2-proxy -n auth 2>/dev/null || echo "  oauth2-proxy not found"
      kubectl rollout restart deployment forgejo -n forgejo 2>/dev/null || echo "  Forgejo not found"
    else
      echo ""
      echo "No secrets changed, skipping pod restarts."
    fi

    echo ""
    echo "=== OIDC Sync Complete ==="
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: zitadel-oidc-sync
  namespace: auth
  labels:
    app.kubernetes.io/name: zitadel-oidc-sync
    app.kubernetes.io/component: setup
    app.kubernetes.io/part-of: zitadel
spec:
  schedule: "*/15 * * * *"  # Every 15 minutes
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 3
  startingDeadlineSeconds: 300
  jobTemplate:
    metadata:
      labels:
        app.kubernetes.io/name: zitadel-oidc-sync
    spec:
      ttlSecondsAfterFinished: 3600  # Keep completed jobs for 1 hour
      backoffLimit: 1
      template:
        metadata:
          labels:
            app.kubernetes.io/name: zitadel-oidc-sync
        spec:
          serviceAccountName: zitadel-oidc-setup
          restartPolicy: Never
          containers:
            - name: setup
              image: alpine/k8s:1.32.11
              command:
                - /bin/sh
                - -c
                - |
                  apk add --no-cache bash curl jq > /dev/null 2>&1
                  /bin/bash /scripts/setup.sh
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
                  readOnly: true
              resources:
                requests:
                  cpu: 10m
                  memory: 64Mi
                limits:
                  memory: 256Mi
          volumes:
            - name: scripts
              configMap:
                name: zitadel-oidc-setup-script
                defaultMode: 0755
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: zitadel-oidc-setup
  namespace: auth
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: zitadel-oidc-setup
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "delete", "get", "list", "patch", "update"]
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get"]
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: zitadel-oidc-setup
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: zitadel-oidc-setup
subjects:
  - kind: ServiceAccount
    name: zitadel-oidc-setup
    namespace: auth
